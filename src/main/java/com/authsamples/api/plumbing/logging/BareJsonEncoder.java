package com.authsamples.api.plumbing.logging;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.encoder.EncoderBase;
import tools.jackson.core.util.DefaultPrettyPrinter;
import tools.jackson.databind.ObjectMapper;
import tools.jackson.databind.node.ObjectNode;

/*
 * A layout containing only a custom object with no fields generated by logback
 */
public final class BareJsonEncoder extends EncoderBase<ILoggingEvent> {

    private final boolean prettyPrint;

    /*
     * Use pretty printing for console output but not file output
     */
    public BareJsonEncoder(final boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }

    /*
     * Return an empty header
     */
    @Override
    public byte[] headerBytes() {
        return new byte[0];
    }

    /*
     * Log from the second parameter passed into method calls such as logger.info
     */
    @Override
    public byte[] encode(final ILoggingEvent event) {
        var text = this.getJsonText(event);
        return text.getBytes();
    }

    /*
     * Return an empty footer
     */
    @Override
    public byte[] footerBytes() {
        return new byte[0];
    }

    /*
     * Do the work to produce JSON text from the logging event
     */
    private String getJsonText(final ILoggingEvent event) {

        var args = event.getArgumentArray();
        if (args.length > 0) {

            // Get the object node back, which was sent from the writeDataItem method of our log entry class
            var data = (ObjectNode) args[0];
            var mapper = new ObjectMapper();

            if (this.prettyPrint) {

                // Write a property per line and an array item per line for exception stack traces
                var prettyPrinter = new DefaultPrettyPrinter();
                prettyPrinter.indentArraysWith(new CustomArrayIndenter());
                return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(data) + System.lineSeparator();

            } else {

                // Set output options to write the JSON object on a single line
                return mapper.writer().writeValueAsString(data) + System.lineSeparator();
            }
        }

        return "";
    }
}
